
OSMix -- a toy operating system framework for teaching OSdev concepts
=====================================================================

This project is an attempt at providing a playground for operating systems
development, aimed at students taking an introductory operating systems course.

OSMix is organized in several stages, which are meant to be gone through mostly
in order, although deviations are possible. Default implementations are
included.


0. The setup
------------

Start developing the operating system by building, starting, and stepping
through a main function on a single architecture.

For this, a couple of bits an pieces are required, that are described below.


0.1. a toolchain
----------------

Choose a target. Building and writing an operating system for a single platform
is hard, but building it for multiple architectures is an entirely different
beast. For the scope of stage 0, we recommend you limit yourself to an
architecture of your choice. I recommend to stick to arm, but if you are more
familiar with a differnt architeture, you can choose that instead.

For your chosen architecture, acquire a toolchain capable of building
bare-metal programs. For arm, this would be an arm-none-eabi- prefixed
toolchain. The operating system kernel you build will not have the luxury of
relying on a running operating system at runtime, which requires special
capabilites from the toolchain.

For debugging, I recommend acquiring a toolchain with gdb included.


0.2. a build system
-------------------

Choose your weapon. You might be tempted to use a high-level build system like
autotools, ant, CMake, meson, scons, gradle and whatever else is out there.
However, you will probably realize that an operating system kernel build is
quite nonstandard, and the flexibility required from the build system is
greater than some of them are comfortable providing.

For the scope of this project, we have chosen to build the kernel with simple,
hand-crafted makefiles for flexibility and ease of understanding, but feel free
to explore whether you can whip your favourite build system into shape and use
that for your build. In the past, I have successfully used autotools to build
a kernel.

To build the kernel, you will need a couple of unusual CFLAGS and LFDLAGS added
to the build. Most prominently, these are -ffreestanding and -nostdlib. These
flags instruct the compiler not to rely on you systems installed c library and
runtime , which are not present at your kernels runtime.

Additionally, based on your chosen platform, there might be more flags to add.
Also, see the compilers documentation for more information on these flags.


0.3. a linker script
--------------------

Linker scripts are the blackest of magics. They allow you to specify the format
of the binary generated by the linker, the order of sections in the binary file
and what is included in them. The segments you may want to include are:

 - a .text segment, this is where the code goes
 - a .rodata segment, for read-only global data
 - a .data segment, for mutable data. you might want to place the stack here
 - a .bss segment, this is where uninitialized static variables live.

Take care to align the segments at page size boundaries of your platform.


0.4. some code to run
---------------------

Write an empty main function. If you try to compile this function into a
kernel, with the appropriate build flags, it will fail because it is missing
the _start function. This function is provided by the C runtime as the true
entry point of the program. You will need to implement this function in
assembler, to set up the environment required for the main() function to...
well... function.

How exactly this works, and what needs to be done depends on the target
platform you chose in 0.1., but in any case you will need to:

 - save input from the boot loader, if any
 - set up the stack pointer
 - expand and zero the .bss segment
 - jump into the main funtion
 - safely handle returns from the main function (e.g. through a spinlock)


0.5. watch it all come together
-------------------------------

Now have your main function return 42, and compile the kernel. Get a system
emulator for your chosen platform -- for arm this would be for example
qemu-system-arm -- and boot up your kernel. Attach a debugger and step through
you init code, and verify that 42 is returned from the main function.

Congratulations, you have written, compiled, run and debugged your very own
operating system kernel. Next, let's make it talk.
